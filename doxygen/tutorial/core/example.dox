/**
  \page tutorial_core_example Example Code

  \ref isvd_dIsvd "iSVD driver" solves an approximate low-rank singular value decomposition of matrix ùë®. \ref demo/cdemo.c is an example code. In the following, we describe the details of each part of this example.

  <h3>Initialize Environment</h3>

  The iSVD environment and random seed should be set up before calling the driver. \ref isvd_init also initialize the MPI environment and the MAGMA environment, and \ref isvd_printEnvironment display the the MPI environment and the MAGMA environment.

  If one needs CPU only, one may use \ref isvd_init_cpu, \ref isvd_printEnvironment_cpu, and \ref isvd_finalize_cpu instead.

  \snippetlineno demo/cdemo.c init-isvd

  <h3>Load Data</h3>

  In this example, we load the data from a Matrix Market format file. Note the all the MPI processors should load the matrix.

  \snippetlineno demo/cdemo.c load-data

  <h3>Allocate matrices</h3>

  The output matrices should be allocated before calling the driver. See \ref isvd_dIsvd for the detail of matrix sizes.

  \snippetlineno demo/cdemo.c allocate-matrix

  <h3>Run iSVD</h3>

  The iSVD driver compute the approximate low-rank singular value decomposition. See \ref isvd_dIsvd for the detail of the arguments. The ùëó-th MPI-rank stores the ùëó-th block of the input matrix ùë® (see \ref tutorial_core_storage for detail).

  \snippetlineno demo/cdemo.c run-isvd

  <h3>Get Executing Time</h3>

  The iSVD driver also records the executing time of each stage.

  \snippetlineno demo/cdemo.c display-time

  <h3>Finalize</h3>

  Remember to \ref isvd_finalize "finalize" the environment.

  \snippetlineno demo/cdemo.c final-isvd

  <h2>Possible Result</h2>

  One may use **make run_cdemo** to run \ref demo/cdemo.c. If you want to compile it directly, please refer the usage guide in the main page. The following are the possible results of the example code.

  \code{.txt}
  iSVD C demo
  iSVD 1.2.0, 32-bit isvd_int_t, 64-bit pointer
  4 MPI processors, 4 OpenMP threads per process

  No GPU support

  Using Real Double Precision Gaussian Projection Sketching
  Using Real Double Precision Gramian Orthogonalization
  Using Real Double Precision Kolmogorov-Nagumo Integration
  Using Real Double Precision Gramian Postprocessing

  Sketching ...................... done
  Orthogonalizing ................ done
  Integrating .................... done
  Postprocessing ................. done

  Average total computing time:   0.085510 seconds.
  Average sketching time:         0.030245 seconds.
  Average orthogonalizing time:   0.028071 seconds.
  Average integrating time:       0.026233 seconds.
  Average postprocessing time:    0.000962 seconds.
  \endcode

*/
